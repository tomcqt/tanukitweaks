{"version":3,"sources":["webpack:///./app/javascript/mastodon/features/list_timeline/index.jsx"],"names":["messages","defineMessages","deleteMessage","id","defaultMessage","deleteConfirm","followed","none","list","ListTimeline","PureComponent","constructor","arguments","handlePin","columnId","dispatch","this","props","removeColumn","addColumn","params","context","router","history","push","handleMove","dir","moveColumn","handleHeaderClick","column","scrollTop","setRef","c","handleLoadMore","maxId","expandListTimeline","handleEditClick","openModal","modalType","modalProps","listId","handleDeleteClick","intl","message","formatMessage","confirm","onConfirm","deleteList","handleRepliesPolicyChange","_ref","target","updateList","undefined","value","onExclusiveToggle","_ref2","checked","componentDidMount","fetchList","disconnect","connectListStream","UNSAFE_componentWillReceiveProps","nextProps","componentWillUnmount","render","hasUnread","multiColumn","pinned","title","get","replies_policy","isExclusive","_jsx","Column","className","LoadingIndicator","BundleColumnError","errorType","_jsxs","bindToDocument","ref","label","children","ColumnHeader","icon","active","onPin","onMove","onClick","type","tabIndex","Icon","FormattedMessage","Toggle","onChange","htmlFor","role","map","policy","RadioButton","name","StatusListContainer","trackScroll","scrollKey","timelineId","onLoadMore","emptyMessage","Helmet","content","contextTypes","PropTypes","object","connect","mapStateToProps","state","getIn","injectIntl"],"mappings":"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","file":"js/features/list_timeline-7170721078b364afc7f5.chunk.js","sourcesContent":["import PropTypes from 'prop-types';\nimport { PureComponent } from 'react';\n\nimport { FormattedMessage, defineMessages, injectIntl } from 'react-intl';\n\nimport { Helmet } from 'react-helmet';\n\nimport ImmutablePropTypes from 'react-immutable-proptypes';\nimport { connect } from 'react-redux';\n\nimport Toggle from 'react-toggle';\n\nimport { addColumn, removeColumn, moveColumn } from 'mastodon/actions/columns';\nimport { fetchList, deleteList, updateList } from 'mastodon/actions/lists';\nimport { openModal } from 'mastodon/actions/modal';\nimport { connectListStream } from 'mastodon/actions/streaming';\nimport { expandListTimeline } from 'mastodon/actions/timelines';\nimport Column from 'mastodon/components/column';\nimport ColumnHeader from 'mastodon/components/column_header';\nimport { Icon }  from 'mastodon/components/icon';\nimport { LoadingIndicator } from 'mastodon/components/loading_indicator';\nimport { RadioButton } from 'mastodon/components/radio_button';\nimport BundleColumnError from 'mastodon/features/ui/components/bundle_column_error';\nimport StatusListContainer from 'mastodon/features/ui/containers/status_list_container';\n\nconst messages = defineMessages({\n  deleteMessage: { id: 'confirmations.delete_list.message', defaultMessage: 'Are you sure you want to permanently delete this list?' },\n  deleteConfirm: { id: 'confirmations.delete_list.confirm', defaultMessage: 'Delete' },\n  followed:   { id: 'lists.replies_policy.followed', defaultMessage: 'Any followed user' },\n  none:    { id: 'lists.replies_policy.none', defaultMessage: 'No one' },\n  list:  { id: 'lists.replies_policy.list', defaultMessage: 'Members of the list' },\n});\n\nconst mapStateToProps = (state, props) => ({\n  list: state.getIn(['lists', props.params.id]),\n  hasUnread: state.getIn(['timelines', `list:${props.params.id}`, 'unread']) > 0,\n});\n\nclass ListTimeline extends PureComponent {\n\n  static contextTypes = {\n    router: PropTypes.object,\n  };\n\n  static propTypes = {\n    params: PropTypes.object.isRequired,\n    dispatch: PropTypes.func.isRequired,\n    columnId: PropTypes.string,\n    hasUnread: PropTypes.bool,\n    multiColumn: PropTypes.bool,\n    list: PropTypes.oneOfType([ImmutablePropTypes.map, PropTypes.bool]),\n    intl: PropTypes.object.isRequired,\n  };\n\n  handlePin = () => {\n    const { columnId, dispatch } = this.props;\n\n    if (columnId) {\n      dispatch(removeColumn(columnId));\n    } else {\n      dispatch(addColumn('LIST', { id: this.props.params.id }));\n      this.context.router.history.push('/');\n    }\n  };\n\n  handleMove = (dir) => {\n    const { columnId, dispatch } = this.props;\n    dispatch(moveColumn(columnId, dir));\n  };\n\n  handleHeaderClick = () => {\n    this.column.scrollTop();\n  };\n\n  componentDidMount () {\n    const { dispatch } = this.props;\n    const { id } = this.props.params;\n\n    dispatch(fetchList(id));\n    dispatch(expandListTimeline(id));\n\n    this.disconnect = dispatch(connectListStream(id));\n  }\n\n  UNSAFE_componentWillReceiveProps (nextProps) {\n    const { dispatch } = this.props;\n    const { id } = nextProps.params;\n\n    if (id !== this.props.params.id) {\n      if (this.disconnect) {\n        this.disconnect();\n        this.disconnect = null;\n      }\n\n      dispatch(fetchList(id));\n      dispatch(expandListTimeline(id));\n\n      this.disconnect = dispatch(connectListStream(id));\n    }\n  }\n\n  componentWillUnmount () {\n    if (this.disconnect) {\n      this.disconnect();\n      this.disconnect = null;\n    }\n  }\n\n  setRef = c => {\n    this.column = c;\n  };\n\n  handleLoadMore = maxId => {\n    const { id } = this.props.params;\n    this.props.dispatch(expandListTimeline(id, { maxId }));\n  };\n\n  handleEditClick = () => {\n    this.props.dispatch(openModal({\n      modalType: 'LIST_EDITOR',\n      modalProps: { listId: this.props.params.id },\n    }));\n  };\n\n  handleDeleteClick = () => {\n    const { dispatch, columnId, intl } = this.props;\n    const { id } = this.props.params;\n\n    dispatch(openModal({\n      modalType: 'CONFIRM',\n      modalProps: {\n        message: intl.formatMessage(messages.deleteMessage),\n        confirm: intl.formatMessage(messages.deleteConfirm),\n        onConfirm: () => {\n          dispatch(deleteList(id));\n\n          if (columnId) {\n            dispatch(removeColumn(columnId));\n          } else {\n            this.context.router.history.push('/lists');\n          }\n        },\n      },\n    }));\n  };\n\n  handleRepliesPolicyChange = ({ target }) => {\n    const { dispatch } = this.props;\n    const { id } = this.props.params;\n    dispatch(updateList(id, undefined, false, undefined, target.value));\n  };\n\n  onExclusiveToggle = ({ target }) => {\n    const { dispatch } = this.props;\n    const { id } = this.props.params;\n    dispatch(updateList(id, undefined, false, target.checked, undefined));\n  };\n\n  render () {\n    const { hasUnread, columnId, multiColumn, list, intl } = this.props;\n    const { id } = this.props.params;\n    const pinned = !!columnId;\n    const title  = list ? list.get('title') : id;\n    const replies_policy = list ? list.get('replies_policy') : undefined;\n    const isExclusive = list ? list.get('exclusive') : undefined;\n\n    if (typeof list === 'undefined') {\n      return (\n        <Column>\n          <div className='scrollable'>\n            <LoadingIndicator />\n          </div>\n        </Column>\n      );\n    } else if (list === false) {\n      return (\n        <BundleColumnError multiColumn={multiColumn} errorType='routing' />\n      );\n    }\n\n    return (\n      <Column bindToDocument={!multiColumn} ref={this.setRef} label={title}>\n        <ColumnHeader\n          icon='list-ul'\n          active={hasUnread}\n          title={title}\n          onPin={this.handlePin}\n          onMove={this.handleMove}\n          onClick={this.handleHeaderClick}\n          pinned={pinned}\n          multiColumn={multiColumn}\n        >\n          <div className='column-settings__row column-header__links'>\n            <button type='button' className='text-btn column-header__setting-btn' tabIndex={0} onClick={this.handleEditClick}>\n              <Icon id='pencil' /> <FormattedMessage id='lists.edit' defaultMessage='Edit list' />\n            </button>\n\n            <button type='button' className='text-btn column-header__setting-btn' tabIndex={0} onClick={this.handleDeleteClick}>\n              <Icon id='trash' /> <FormattedMessage id='lists.delete' defaultMessage='Delete list' />\n            </button>\n          </div>\n\n          <div className='setting-toggle'>\n            <Toggle id={`list-${id}-exclusive`} checked={isExclusive} onChange={this.onExclusiveToggle} />\n            <label htmlFor={`list-${id}-exclusive`} className='setting-toggle__label'>\n              <FormattedMessage id='lists.exclusive' defaultMessage='Hide these posts from home' />\n            </label>\n          </div>\n\n          { replies_policy !== undefined && (\n            <div role='group' aria-labelledby={`list-${id}-replies-policy`}>\n              <span id={`list-${id}-replies-policy`} className='column-settings__section'>\n                <FormattedMessage id='lists.replies_policy.title' defaultMessage='Show replies to:' />\n              </span>\n              <div className='column-settings__row'>\n                { ['none', 'list', 'followed'].map(policy => (\n                  <RadioButton name='order' key={policy} value={policy} label={intl.formatMessage(messages[policy])} checked={replies_policy === policy} onChange={this.handleRepliesPolicyChange} />\n                ))}\n              </div>\n            </div>\n          )}\n        </ColumnHeader>\n\n        <StatusListContainer\n          trackScroll={!pinned}\n          scrollKey={`list_timeline-${columnId}`}\n          timelineId={`list:${id}`}\n          onLoadMore={this.handleLoadMore}\n          emptyMessage={<FormattedMessage id='empty_column.list' defaultMessage='There is nothing in this list yet. When members of this list post new statuses, they will appear here.' />}\n          bindToDocument={!multiColumn}\n        />\n\n        <Helmet>\n          <title>{title}</title>\n          <meta name='robots' content='noindex' />\n        </Helmet>\n      </Column>\n    );\n  }\n\n}\n\nexport default connect(mapStateToProps)(injectIntl(ListTimeline));\n"],"sourceRoot":""}